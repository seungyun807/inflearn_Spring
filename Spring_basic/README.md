< 인프런 spring 핵심 원리 - 기본편 >
--------------

5 / 24
>    ( 객체 지향 설계와 스프링 ~ 회원 도메인 실행과 테스트 )

5 / 28
>    ( 주문과 할인 도메인 설계 ~ 관심사의 분리 )
- discount, order 두가지로 나누워 역할 구분 (단일 책임의 원칙)
- AppConfig를 통해 관심사를 분리한다. (의존관계 주입)

5 / 31
>    ( AppConfig 리팩터링 ~ 스프링 빈 설정 메타 정보 )
- 적절한 객체 지향의 설계
- 컨테이너 적용
- 스프링 컨테이너를 생성하면 빈 저장소에 파라미터로 넘어온 설정 클래스 정보를 사용해 저장
- 여러가지 방법으로 빈 조회 가능
- 상속 관계 조회, 부모 타입으로 조회하면, 자식 타입도 함께 조회된다.
- Xml로도 bean 설정 가능 ( 하지만 근래엔 잘 사용하지 않음)
- 스프링 빈 설정 메타 정보 - BeanDefinition
- 빈의 다양한 설정은 BeanDefinition이라는 추상화가 존재
- XML, 자바 코드를 읽어 BeanDefinition 생성
- BeanDefinition은 빈 설정 메타정보 -> 스프링 컨테이너는 이 메타정보를 기반으로 빈 생성

6 / 1
>   ( 싱글톤 컨테이너 )
- AppConfig에 요청을 할 때 마다 객체를 새로 생성한다.
- 이는 메모리 낭비가 심하다. -> 싱글톤 패턴으로 해결해야 한다.
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- static으로 instance를 하나 생성해서 올린다.
- 싱글톤 패턴의 다양한 문제점 -> 코드 수 증가, 구체 클래스 의존 등 다수의 문제 존재
- 싱글톤 컨테이너로 해당 문제를 해결 가능
- 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
- ThreadA가 코드를 호출시 ThreadB가 또 호출 할 시 ThreadA의 필드를 변경하는 오류 발생
- 위와 같은 문제는 공유필드로 인한 문제. 스프링 빈은 항상 무상태(stateless)로 설계
- @Configuration은 @CGLIB를 통해 상위 클래스를 조작해 자식 타입으로 만든다.
- 스프링 컨테이너에 등록 되어있는 클래스라면 등록된 클래스를 찾아서 반환
- 등록되지 않은 클래스라면 등록
- 이렇게 스프링 컨테이너는 싱글톤을 보장, 항상 @Configuration과 @Bean을 같이 사용

6 / 2
>   ( 컴포넌트 스캔 )
- 실제 개발시 많은 빈을 등록해야 하므로 자동으로 빈을 등록하는 컴포넌트 스캔
- 또 의존관계도 자동으로 주입하는 @Autowired도 존재한다.
- @ComponentScan을 설정 정보에 붙여준다.
- @Component 에노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.
- 탐색 위치는 디폴트는 해당 class가 있는 위치부터 하위로 탐색
- basePackages를 통해 시작위치를 지정 할 수도 있다.
- @Component, @Controller, @Service, @Repository, @Configuration도 자동 등록
- includeFilters, excludeFilters를 통해 스캔 대상을 추가, 제외 할 수 있다.
- 자동 빈 등록시 중복이면 충돌, 수동, 자동 빈 등록시 과거엔 오버라이드, 현재는 오류
