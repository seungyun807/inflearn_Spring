< 인프런 spring 핵심 원리 - 기본편 >
--------------

5 / 24
>    ( 객체 지향 설계와 스프링 ~ 회원 도메인 실행과 테스트 )

5 / 28
>    ( 주문과 할인 도메인 설계 ~ 관심사의 분리 )
- discount, order 두가지로 나누워 역할 구분 (단일 책임의 원칙)
- AppConfig를 통해 관심사를 분리한다. (의존관계 주입)

5 / 31
>    ( AppConfig 리팩터링 ~ 스프링 빈 설정 메타 정보 )
- 적절한 객체 지향의 설계
- 컨테이너 적용
- 스프링 컨테이너를 생성하면 빈 저장소에 파라미터로 넘어온 설정 클래스 정보를 사용해 저장
- 여러가지 방법으로 빈 조회 가능
- 상속 관계 조회, 부모 타입으로 조회하면, 자식 타입도 함께 조회된다.
- Xml로도 bean 설정 가능 ( 하지만 근래엔 잘 사용하지 않음)
- 스프링 빈 설정 메타 정보 - BeanDefinition
- 빈의 다양한 설정은 BeanDefinition이라는 추상화가 존재
- XML, 자바 코드를 읽어 BeanDefinition 생성
- BeanDefinition은 빈 설정 메타정보 -> 스프링 컨테이너는 이 메타정보를 기반으로 빈 생성

6 / 1
>   ( 싱글톤 컨테이너 )
- AppConfig에 요청을 할 때 마다 객체를 새로 생성한다.
- 이는 메모리 낭비가 심하다. -> 싱글톤 패턴으로 해결해야 한다.
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- static으로 instance를 하나 생성해서 올린다.
- 싱글톤 패턴의 다양한 문제점 -> 코드 수 증가, 구체 클래스 의존 등 다수의 문제 존재
- 싱글톤 컨테이너로 해당 문제를 해결 가능
- 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
- ThreadA가 코드를 호출시 ThreadB가 또 호출 할 시 ThreadA의 필드를 변경하는 오류 발생
- 위와 같은 문제는 공유필드로 인한 문제. 스프링 빈은 항상 무상태(stateless)로 설계
- @Configuration은 @CGLIB를 통해 상위 클래스를 조작해 자식 타입으로 만든다.
- 스프링 컨테이너에 등록 되어있는 클래스라면 등록된 클래스를 찾아서 반환
- 등록되지 않은 클래스라면 등록
- 이렇게 스프링 컨테이너는 싱글톤을 보장, 항상 @Configuration과 @Bean을 같이 사용

6 / 2
>   ( 컴포넌트 스캔 )
- 실제 개발시 많은 빈을 등록해야 하므로 자동으로 빈을 등록하는 컴포넌트 스캔
- 또 의존관계도 자동으로 주입하는 @Autowired도 존재한다.
- @ComponentScan을 설정 정보에 붙여준다.
- @Component 에노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.
- 탐색 위치는 디폴트는 해당 class가 있는 위치부터 하위로 탐색
- basePackages를 통해 시작위치를 지정 할 수도 있다.
- @Component, @Controller, @Service, @Repository, @Configuration도 자동 등록
- includeFilters, excludeFilters를 통해 스캔 대상을 추가, 제외 할 수 있다.
- 자동 빈 등록시 중복이면 충돌, 수동, 자동 빈 등록시 과거엔 오버라이드, 현재는 오류

6 / 3
>   ( 의존관계 자동 주입 )
- 생성자, 수정자, 필드, 일반 메서드 주입 4가지 방법이 존재
- @Autowired만 사용하면 required의 옵션 값이 기본적으로 true, 
- 스프링 빈이 아닌 클래스에서 자동 주입 대상이 없어 오류 발생, false를 준다.
- 생성자 주입을 선택하자, 의존관계 주입은 애플리케이션 종료 시점까지 의존관계를 변경할 일이 없다.
- 의존관계는 애플리케이션 종료 전까지 변하면 안된다. (불변해야함)
- 수정자 의존관계인 경우 누락 발생
- 항상 생성자 주입을 선택하되 옵션이 필요한 경우면 수정자 주입을 선택
- 롬복 @RequiredArgsConstructior 기능을 사용하면 final이 붙은 필드를 모아서 자동으로 생성자를 만들어준다.
- 조회 빈이 2개 이상일때, @Autowired필드 명, @Qualifier, @Primary
- @Autowired는 타입 매칭을 시도하고, 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭
- @Qualifier는 추가 구분자를 붙여준다. 주입시 추가적인 방법을 제공할 뿐, 빈 이름 변경 x
- 생성자 자동 주입시 @Qualifier("~")를 붙여줌, 못 찾을시 해당 이름으로 빈을 추가로 찾는다.
- @Qualifier끼리 매칭, 빈 이름 매칭,  NoSuchBeanDefinitionException 예외 발생
- @Primary -> 우선순위, 메인 @Primary, 서브 옵션으로 @Qualifier를 사용
- 우선순위는 @primary < @Qualifier
- 애노테이션을 직접 만들수도 있다. 직접 만들어 해당 빈에 애노테이션을 붙여준다. 생성자에도 붙여준다.
- 조회한 빈이 모두 필요할 때, List, Map을 사용
- 업무 로직 빈 -> 자동, 기술 지원 빈 -> 수동
- 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈 -> 유지보수 향상
- 조회한 빈이 모두 필요할 때, 타인이 보면 어렵다.
- 이런 경우 수동 빈으로 등록하거나 또는 자동으로하면 특정 패키지에 같이 묶어두는 것이 좋다.
- 자동 기능을 기본으로, 직접 등록하는 기술 지원 개체는 수동, 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민
