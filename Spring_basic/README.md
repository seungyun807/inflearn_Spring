< 인프런 spring 핵심 원리 - 기본편 >
--------------

5 / 24
>    ( 객체 지향 설계와 스프링 ~ 회원 도메인 실행과 테스트 )

5 / 28
>    ( 주문과 할인 도메인 설계 ~ 관심사의 분리 )
- discount, order 두가지로 나누워 역할 구분 (단일 책임의 원칙)
- AppConfig를 통해 관심사를 분리한다. (의존관계 주입)

5 / 31
>    ( AppConfig 리팩터링 ~ 스프링 빈 설정 메타 정보 )
- 적절한 객체 지향의 설계
- 컨테이너 적용
- 스프링 컨테이너를 생성하면 빈 저장소에 파라미터로 넘어온 설정 클래스 정보를 사용해 저장
- 여러가지 방법으로 빈 조회 가능
- 상속 관계 조회, 부모 타입으로 조회하면, 자식 타입도 함께 조회된다.
- Xml로도 bean 설정 가능 ( 하지만 근래엔 잘 사용하지 않음)
- 스프링 빈 설정 메타 정보 - BeanDefinition
- 빈의 다양한 설정은 BeanDefinition이라는 추상화가 존재
- XML, 자바 코드를 읽어 BeanDefinition 생성
- BeanDefinition은 빈 설정 메타정보 -> 스프링 컨테이너는 이 메타정보를 기반으로 빈 생성

6 / 1
>   ( 싱글톤 컨테이너 )
- AppConfig에 요청을 할 때 마다 객체를 새로 생성한다.
- 이는 메모리 낭비가 심하다. -> 싱글톤 패턴으로 해결해야 한다.
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- static으로 instance를 하나 생성해서 올린다.
- 싱글톤 패턴의 다양한 문제점 -> 코드 수 증가, 구체 클래스 의존 등 다수의 문제 존재
- 싱글톤 컨테이너로 해당 문제를 해결 가능
- 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
- ThreadA가 코드를 호출시 ThreadB가 또 호출 할 시 ThreadA의 필드를 변경하는 오류 발생
- 위와 같은 문제는 공유필드로 인한 문제. 스프링 빈은 항상 무상태(stateless)로 설계
- @Configuration은 @CGLIB를 통해 상위 클래스를 조작해 자식 타입으로 만든다.
- 스프링 컨테이너에 등록 되어있는 클래스라면 등록된 클래스를 찾아서 반환
- 등록되지 않은 클래스라면 등록
- 이렇게 스프링 컨테이너는 싱글톤을 보장, 항상 @Configuration과 @Bean을 같이 사용

6 / 2
>   ( 컴포넌트 스캔 )
- 실제 개발시 많은 빈을 등록해야 하므로 자동으로 빈을 등록하는 컴포넌트 스캔
- 또 의존관계도 자동으로 주입하는 @Autowired도 존재한다.
- @ComponentScan을 설정 정보에 붙여준다.
- @Component 에노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.
- 탐색 위치는 디폴트는 해당 class가 있는 위치부터 하위로 탐색
- basePackages를 통해 시작위치를 지정 할 수도 있다.
- @Component, @Controller, @Service, @Repository, @Configuration도 자동 등록
- includeFilters, excludeFilters를 통해 스캔 대상을 추가, 제외 할 수 있다.
- 자동 빈 등록시 중복이면 충돌, 수동, 자동 빈 등록시 과거엔 오버라이드, 현재는 오류

6 / 3
>   ( 의존관계 자동 주입 )
- 생성자, 수정자, 필드, 일반 메서드 주입 4가지 방법이 존재
- @Autowired만 사용하면 required의 옵션 값이 기본적으로 true, 
- 스프링 빈이 아닌 클래스에서 자동 주입 대상이 없어 오류 발생, false를 준다.
- 생성자 주입을 선택하자, 의존관계 주입은 애플리케이션 종료 시점까지 의존관계를 변경할 일이 없다.
- 의존관계는 애플리케이션 종료 전까지 변하면 안된다. (불변해야함)
- 수정자 의존관계인 경우 누락 발생
- 항상 생성자 주입을 선택하되 옵션이 필요한 경우면 수정자 주입을 선택
- 롬복 @RequiredArgsConstructior 기능을 사용하면 final이 붙은 필드를 모아서 자동으로 생성자를 만들어준다.
- 조회 빈이 2개 이상일때, @Autowired필드 명, @Qualifier, @Primary
- @Autowired는 타입 매칭을 시도하고, 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭
- @Qualifier는 추가 구분자를 붙여준다. 주입시 추가적인 방법을 제공할 뿐, 빈 이름 변경 x
- 생성자 자동 주입시 @Qualifier("~")를 붙여줌, 못 찾을시 해당 이름으로 빈을 추가로 찾는다.
- @Qualifier끼리 매칭, 빈 이름 매칭,  NoSuchBeanDefinitionException 예외 발생
- @Primary -> 우선순위, 메인 @Primary, 서브 옵션으로 @Qualifier를 사용
- 우선순위는 @primary < @Qualifier
- 애노테이션을 직접 만들수도 있다. 직접 만들어 해당 빈에 애노테이션을 붙여준다. 생성자에도 붙여준다.
- 조회한 빈이 모두 필요할 때, List, Map을 사용
- 업무 로직 빈 -> 자동, 기술 지원 빈 -> 수동
- 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈 -> 유지보수 향상
- 조회한 빈이 모두 필요할 때, 타인이 보면 어렵다.
- 이런 경우 수동 빈으로 등록하거나 또는 자동으로하면 특정 패키지에 같이 묶어두는 것이 좋다.
- 자동 기능을 기본으로, 직접 등록하는 기술 지원 개체는 수동, 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민

6 / 10
>   ( 빈 생명주기 콜백 )
- 스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에 필요한 데이터를 사용할 수 있는 준비가 완료
- 초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야함
- 스프링 빈의 이벤트 라이프 사이클
- 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료
- 애노테이션 @PostConstruct, @PreDestroy <- 스프링에서 최근에 가장 권장하는 방법
- 자바 표준으로써 스프링이 아닌 다른 컨테이너에서도 동작
- 외부 라이브러리에는 적용하지 못함, 종료해야 하면 @Bean의 initMethod, destroyMethod를 사용

6 / 11
>   ( 빈 스코프 )
- 스코프는 빈이 존재할 수 있는 범위를 뜻함
- 싱글톤, 프로토타입, 웹 관련 스코프가 존재
- 프로토타입 스코프는 항상 새로운 인스턴스를 생성해서 반환
- 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리
- 종료 메서드가 호출되지 않아 프로토타입 빈을 조회한 클라이언트가 관리해야 한다.
- 프로토타입 빈을 주입 시점에만 새로 생성하는게 아니라, 사용할때 마다 새로 생성해서 사용하는 것을 원한다.
- Provider사용 싱글톤 빈이 프로토타입을 사용할 때 마다 스프링 컨테이너에 새로 요청
- 하지만 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워짐
- ObjectFactory -- (편의성 추가) --> ObjectProvider 지정한 빈을 컨테이너에서 대신 찾아주는 DL서비스를 제공
- getObject()를 통해서 항상 새로운 프로토타입 빈이 생성되는걸 확인
- javax.inject.Provider 자바 표준을 사용하는 방법 get()을 통해 항상 새로운 프로토타입 빈이 생성되는 것을 확인
- 웹 스코프는 스프링이 해당 스코프의 종료시점까지 관리, 종료 메서드가 호출
- request, session, application, websocket
- request 스코프 빈은 생성되지 않는다. 이 빈은 실제 고객의 요청이 와야 생성 가능
- Provider 사용을 통해 해결 가능 -> 프록시가 더 깔끔
- 프록시는 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있다.
- Provider, 프록시는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점
- 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체 가능, 다형성과 DI컨테이너가 가진 큰 강점
- 마치 싱글톤을 사용하는 것 같지만 다르게 동작하기 때문에 주의해서 사용
- 꼭 필요한 곳에만 최소화해서 사용, 무분별하게 사용하면 유지보수하기 어려워짐
